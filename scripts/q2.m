function younglab_model_spm12_pleiades(varargin)
% 
% younglab_model_spm12
% 
% Batch function for specifying and modeling a design matrix for one or
% more subjects in SPM8. At the minimum, it requires four arguments at the
% beginning: study, subject IDs, tasks, and bold directories. 
%
% E.G. younglab_model_spm8('BLI','YOU_BLI_01','fba',[4 8 14])
%       ==> would attempt to model  audio fb task (fba) for bold runs 005,
%           009, and 014 in a new directory called
%           '<experiment root dir>/BLI/YOU_BLI_01/results/fba_results'
%
% In addition, there are a number of optional parameters that affect the 
% behavior of the script. By default, the following behavior will take
% place:
%         - Use an explicit mask generated by FSL with a threshold of 0.4
%         - Run art_batch, saving the regressors and including a screenshot
%             of the results, but not including the regressors in the 
%             behavioural files. 
%         - Use a filtering frequency of 128 seconds per cycle. 
%         - Assume data are normalized.
%         
% *********************** Options *****************************************
% All parameters may be modified by including extra arguments to the script
% in the form of strings. There are two types, "option" parameters and 
% assignment parameters. Option parameters are single inputs that cause the
% script to change between discrete modes of operation. Assignment 
% parameters change the value of a variable. 
% 
% Option parameters:
%     => 'RT'             Causes the script to integrate reaction-time 
%                         regressors
%                         
%     => 'unnormed'       The script will expect unnormalized data.
%     
%     => 'implicit_mask'  The script will use SPM's implicit masking, with a 
%                         default masking threshold of 80% mean signal.
%                         
%     => 'no_art'         The script will not run artifact detection.
%     
%     => 'legacy'         The script will function exactly as its 
%                         predecessor, saxelab_model_bch_spm8.
%     
%     => 'overwrite_mask' The script's default behavior is now to overwrite 
%                         any mask that it finds. The 'overwrite_mask'
%                         option (confusingly) will disable this, causing
%                         it to *not* overwrite the mask. 
%
%	  => 'dont_smash'	  Instead of overwriting old models, the script will
%						  simply generate more by appending a value onto
%						  the end of the directory name. 
%
%	  => 'clobber'		  The script will now clobber old results
%						  whose names collide with current results
%						  directories without asking permission first.
%
% Assignment parameters:
%     These variables all change the behavior of the script by directly
%     changing the value of a variable.
%     => 'maskthresh = number'
%         Changes the masking threshold. Remember, whereas SPM uses percent
%         as the means of expressing the masking threshold, FSL uses 
%         decimal values. Therefore, '80' in SPM as the masking threshold 
%         is the equivalent of '0.8' in FSL. 
%         Default (explicit mask): 0.5
%         Default (implicit mask): 80
%      
%     => 'filter_frequency = number'
%         Changes the frequency cutoff for the high pass filter. The script
%         will warn you if you attempt to use a bad filtering frequency,
%         but changing it ahead of time will circumvent that. Expressed as 
%         seconds-per-period. 'filter_frequency = 200' will filter anything
%         with a period greater than 200 seconds, or a frequency lower than
%         1/200 Hz. 
%         
%     => 'global_threshold = number' 
%         threshold for outlier detection based on global signal 
%         (default = 3)
%         
%     => 'motion_threshold = number' 
%         threshold for outlier detection based on motion 
%         (default = 2)
%         
%     => 'use_diff_motion = 1 or 0' 
%         1: uses scan-to-scan motion to determine outliers
%         0: uses absolute motion 
%         (default = 1)
%         
%     => 'use_diff_global = 1 or 0' 
%         1: uses scan-to-scan global signal change to determine outliers
%         0: uses absolute global signal values
%         (default = 0)
%         
%     => 'root_dir = STRING'      
%         Changes the root directory. Should probably not be used. If you
%         must change the root directory, you must pass it in with escaped
%         quotes. Like: 'root_dir = ''some string'''
%
%	  => 'old_names = 1'
%		  This causes the script to assume the same naming conventions as
%		  the old modeling script (i.e. naming it purely based on the behavioural
%		  file and whether or not the data was normalized.)
%         
% Some usage examples:
% 
% saxelab_newmodel_spm('MNM',{'YOU_MNM_01','YOU_MNM_02'},'mnm',[6 8 10 12],'unnormed','implicit_mask','maskthresh = 60');
% 
%     This would perform the analysis, but on unnormed data, and using SPM's 
%     own masking system. Since the masking threshold defaults to 80% if you 
%     specify an implicit mask, the user has changed it to 60%. 
% 
% Additional Notes:
% 
%     - The script saves a screenshot of the art_batch results as 
%       artifact_analysis_SUBJECT_TASK.png
%	  - The script will save screenshots of its frequency analysis on the
%	    conditions being run, so that you can review them later. 
%     - The script will never overwrite old data, instead it will simply 
%       create a new results directory with the same name but a "2" or "3" 
%       (etc) appended to it.
%     - The script saves information about who performed the analysis, 
%       when it was performed, and the parameters used in a text file stored
%       in the results directory, named 'whatever the results directory is + 
%       metadata.txt'
%     - The script remodeler() will integrate artifact data, by changing 
%       the behavioural files and modeling again using this script.
%        
%  ======================= Multi-subject/task batching =======================
% The logic governing the interpretation of 'subjIDs' is the same as in
% the dicom and preprocessing scripts - If provided with a string the
% script will search through '<software root dir>/study' for a match, and if none is
% found it will attempt to use this string as a filter on this directory
% instead.  The script interprets a cell array as a list of subjects.
%
% Both 'tasks' and 'boldirs' may also be elaborated into cells that
% saxelab_model_bch will then attempt to step through, but the effect is the
% same as repeating the function call with each argument.  For both args,
% provide information about the task within subject information.  That is,
% provide a cell that contains a series of task cells within subject cells.
%       e.g. {{'task1','task2'},{'task1','task3'}}
%
% E.G. (simple)
% saxelab_newmodel_spm8('BLI','YOU_BLI_01','fbv',[3 10 13])
% E.G. (crazy)
% YOUelab_newmodel_spm8('BLI',{'YOU_BLI_01','YOU_BLI_02','YOU_BLI_03'},...
% {{'fba','fbv','BLI'},{'fba','BLI},{'fbv','fba','BLI'}},{{[5 9 ...
% 14],[3 10 13],[7 8 11 12]},{[5 10 13],[7 8 11 12]},{[3 9 12],[4 8 13],...
% [6 7 10 11]}})
% This one actually would work, provided behavioural data, but in practice
% will typically only be run by your pstream script in which all these
% values are hard coded.

% Usage note:
% 1) This script depends on the presense of the 2 variables 'ips' and
% 'spm_inputs' in an individual mat file for every run that is to be
% included in the model.  These matfiles should be located in the 'behavioural'
% directory and named with the following format: subjID.task.acq.mat
%       ips is a integer used to set the number of functional runs
%       spm_inputs is a scructure with fields name, ons, and dur
%
% 2) The script also searches for the optional variables "con_info" and
% "user_regressors".
%   Syntax:
%       con_info(index).name = 'some name';
%       con_info(index).vals = [array of values of length numruns];
%
%       user_regressors(index).name = 'regressor name';
%       user_regressors(index).ons = [array of numbers of length ips];
%       
%
% 3) IMPORTANT: these files are loaded by filtering the directory, NOT
% directly.  Therefore the script knows nothing of acq numbers, and to
% exclude a run from the model you must MOVE/REMOVE the appropriate matfile
% from the behavioural directory.  It is not enough to simply omit the bold
% directory in the function call (unless it was the last run), since the
% script sequentially pairs the list of matfiles to corresponding boldirs.
% 4) In cases where tasks or boldirs is the same across subjects you may
% omit repetitions - the script copies the first cell out to the
% appropriate number of subjects
%
% Created by npd - 11/15/2010

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin by processing all the variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% turn off window elements
set(0,'DefaultFigureVisible','off');

global EXPERIMENT_ROOT_DIR
global skip_art;
global mask_over;
global defaults;

% add FSL to the path and set FSL environment variables
% setenv('PATH',[getenv('PATH') ':/usr/lib/fsl/5.0']);
% setenv('FSLDIR','/usr/local/fsl');
% setenv('FSLOUTPUTTYPE','NIFTI_GZ');
addpath(genpath('/home/younglw/lab/scripts'));
addpath(genpath('/usr/public/spm/spm12'));
EXPERIMENT_ROOT_DIR = '/home/younglw/lab';
TR               = 2;
src_data_flag    = 'normed'; 
RT_flag          = 0;
implicit_flag    = 0;
filter_frequency = 128;
maskthresh       = 0.4;
global_mean      = 1;
motion_file_type = 0;
global_threshold = 3;
motion_threshold = 2;
use_diff_motion  = 1;
use_diff_global  = 0;
addMotion        = 0;
addRegressors    = 0;
saveim           = 1; 
addOnlyMotion    = 0;
skip_art         = 0;
mask_is_def      = 0;
freq_is_def      = 0;
is_legacy        = 0;
mask_over        = 1;
dont_smash		 = 0;
old_names		 = 0;
clobber_bit		 = 0;

defaults.maskthresh = maskthresh;
defaults.filter_frequency = filter_frequency;
defaults.implicit_flag = implicit_flag; 

if nargin == 0
    help younglab_model_spm8;
    return;
elseif nargin<4
    disp('error: younglab_model_spm8 requires a minimum of 4 arguments');
    disp('`study`, `subjIDs`, `tasks`, & `boldirs` required');
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process study + subjects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Elaborate subjects into a cell if they're not in one already
if ~iscell(varargin{2})
    varargin{2} = {varargin{2}};
end

study           = varargin{1};
subject         = varargin{2};

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process tasks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~iscell(varargin{3})
    disp('Warning: `tasks` argument not provided in cell format!');
    tasks = {{varargin{3}}};
elseif iscell(varargin{3}{1})
    tasks = varargin{3};
else
    tasks = {varargin{3}};
end
for lazy = (length(tasks)+1):(length(subject)-length(tasks)+1)
    tasks{lazy} = tasks{1};
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process bold directories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~iscell(varargin{4})
	disp('Warning: `boldirs` argument not provided in cell format!');
end
if strcmp(class(varargin{4}),'double')
    boldirs = {{varargin{4}}};
elseif iscell(varargin{4}{1})
    boldirs = varargin{4};
elseif iscell(varargin{4}) & iscell(varargin{2}) % assume that each array w/in a cell refers to a separate subj, not a separate task
    for i=1:length(varargin{4});boldirs{i} = varargin{4}(i);end;
elseif iscell(varargin{4}) & isstr(varargin{2}) % assume that there is one subject w/ several tasks and partition vararg 4 appropriately 
    boldirs = {varargin{4}};
end
for lazy = (length(boldirs)+1):(length(subject)-length(boldirs)+1)
    boldirs{lazy} = boldirs{1};
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now iterate through the 
% remaining varargin values, and
% assign variables as necessary.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for i = 5:length(varargin)
    switch varargin{i}
        case 'RT'
            RT_flag = 1; 
        case 'unnormed'
            src_data_flag = 'unnormed';
        case 'normed'
            src_data_flag = 'normed';
        case 'implicit_mask'
            implicit_flag = 1;
            if ~mask_is_def
                maskthresh    = 80;
            end
        case 'no_art'
            skip_art = 1;
        case 'legacy'
            is_legacy = 1;
        case 'overwrite_mask'
            mask_over = 0;
		case 'dont_smash'
			dont_smash = 1;
		case 'clobber'
			clobber_bit = 1;
        otherwise
            try
                eval(varargin{i});
                if strfind(varargin{i},'maskthresh')
                    mask_is_def = 1;
                end
                if strfind(varargin{i},'filter_frequency')
                    freq_is_def = 1;
                end
            catch
                disp(fprintf('''%s'' returned an error. Ignoring.',varargin{i}));
            end
    end
end

if is_legacy
    skip_art = 1;
    implicit_flag    = 1;
    filter_frequency = 128;
    maskthresh       = 80;
end
    
global inStruct;

inStruct.global_mean = global_mean; 
inStruct.motion_file_type = motion_file_type; 
inStruct.global_threshold = global_threshold;
inStruct.motion_threshold = motion_threshold;
inStruct.use_diff_motion = use_diff_motion;
inStruct.use_diff_global = use_diff_global;
inStruct.addMotion = addMotion; 
inStruct.saveim = saveim;    
inStruct.addRegressors = addRegressors; 
inStruct.addOnlyMotion = addOnlyMotion; 
inStruct.old_names = old_names; 
inStruct.src_data_flag = src_data_flag;
inStruct.dont_smash = dont_smash;
inStruct.clobber_bit = clobber_bit;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now iterate through the 
% behavioral files, and check 
% that the onsets of the 
% conditions do not exceed the 
% frequency cutoff for the 
% high-pass filter. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% if ~is_legacy & ~freq_is_def
%     curDir = pwd; 
%     longestPeriod = 0; 
%     cd(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural'));
%     for subj = 1:length(subject)
%         for task = 1:length(tasks{subj})
%             behavdata_thistask = dir(sprintf('%s.%s.*.mat',subject{subj},tasks{subj}{task}));
%             num_behav_files = length(behavdata_thistask);
%             if num_behav_files
%                 for i=1:num_behav_files
%                     load(behavdata_thistask(i).name,'spm_inputs');
%                     for j=1:length(spm_inputs)
%                         if length(spm_inputs(j).ons) == 1
%                             % what do you do if there is only one instance of a
%                             % condition?
%                         else    
%                             for k=1:(length(spm_inputs(j).ons)-1)
%                                 thisPeriod = spm_inputs(j).ons(k+1) - spm_inputs(j).ons(k);
%                                 if thisPeriod > longestPeriod
%                                     longestPeriod = thisPeriod;
%                                 end
%                             end
%                         end
%                     end
%                     clear spm_inputs
%                 end
%             end
%         end
%     end
%     load(behavdata_thistask(i).name,'ips');
% 
%     if longestPeriod*2 > filter_frequency
%         fprintf('\nWARNING: The longest time between onsets for any condition \nin this analysis is %.0f seconds, while your filter is set \nto %.0f seconds. Recommend you set a larger frequency \nfor filter.\n',longestPeriod*2,filter_frequency); 
%         change_bpf = input(sprintf('Would you like to change it? y/[n]:\t\t'), 's');   
%         if strcmp(change_bpf,'Y') | strcmp(change_bpf,'y')
%             if longestPeriod*1.5 > ips
%                 recommendedPeriod = ips*2;
%             else
%                 recommendedPeriod = longestPeriod*2*1.2;
%             end
%             filter_frequency = input(sprintf('Input new frequency cutoff (recommend %.0f) in seconds / cycle:\t\t',recommendedPeriod));
%         end 
%     end
%     cd(curDir);
% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin modeling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


tic;
[ErrorLog,SPM]=model(study,subject,tasks,boldirs,src_data_flag,TR,RT_flag,implicit_flag,filter_frequency,maskthresh);

model_time_el = toc; 

% show errors if log isn't empty:
err_bool = (length(ErrorLog)>0);
err_strs = {'without','with'};
if err_bool
    ErrorLog{:}
end
fprintf('Design & estimation completed %s errors in %d minutes and %.1f seconds\n',err_strs{1+err_bool},floor(model_time_el/60),mod(model_time_el,60));
set(0,'DefaultFigureVisible','on');
cd(fullfile(EXPERIMENT_ROOT_DIR,study));
end % Main Body

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-------------------------------------------------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [ErrorLog,SPM]=model(study,subject,tasks,boldirs,src_data_flag,TR,RT_flag,implicit_flag,filter_frequency,maskthresh)
global EXPERIMENT_ROOT_DIR;
global skip_art;
global defaults;
global inStruct;
ErrorLog={};SPM=[];

if strmatch(src_data_flag,'normed')
    filter = 'swraf*img';
elseif strmatch(src_data_flag,'unnormed')
    filter = 'sraf*img';
else
    disp('src_data_flag: illegal value.  "normed" & "unnormed" allowed');
end

for subj = 1:length(subject)
%     try
        fprintf('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n');
        fprintf('Beginning estimation & contrasts on subject %s \n',subject{subj});
        fprintf('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n');
        
        for task = 1:length(tasks{subj})
            fprintf('Subject: %s    Task: %s\n',subject{subj},tasks{subj}{task});
            clear spm_inputs con_info ips scans; SPM=[];
            cd(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural'));
            behavdata_thistask = dir(sprintf('%s.%s.*.mat',subject{subj},tasks{subj}{task}));
            num_behav_files = length(behavdata_thistask); % grabs mat files for this task for all acq
            clear vec;
            if num_behav_files
                % now do some explicit sorting (bug realized in prose for alpha-sort)
                for i=1:num_behav_files % zip through the files and excerpt the acq #
                    therest = behavdata_thistask(i).name; % initialize for strtok
                    while ~strcmp(therest,'.mat')
                        [str,therest] = strtok(therest,'.'); % parse for acq
                    end
                    vec(i)=str2num(str);
                end
                sorted_vec = sort(vec);  % run numerical sort
                clear parafiles; % else you will run into problems when subject n has fewer behavioural files than subject n-1
                for i=1:num_behav_files
                    parafiles{i}=behavdata_thistask(vec==sorted_vec(i)).name; % finally reorganize w/ find
                end
            else
                error(sprintf('Couldn''t find behavioural data matching %s.%s.*.mat',subject{subj},tasks{subj}{task}));
            end
            num_runs = length(boldirs{subj}{task}); %prevents runover from excess behav data
            if num_runs ~= num_behav_files
                fprintf('Warning: number of behavioural data files does not match the\n');
                fprintf('number of runs for subject %s\n',subject{subj});
            end

            scans = [];
            
            cd(fullfile(EXPERIMENT_ROOT_DIR,study,subject{subj},'results'));
            % BUILD RESULTS STRING 
            % (constructs an appropriate name for the results)
            results_string = [tasks{subj}{task} '_results_' src_data_flag];
			if ~inStruct.old_names
				if RT_flag
					results_string = [results_string '_RT'];
				end
				if implicit_flag
					results_string = [results_string '_IMP_maskt'];
					if maskthresh ~= 80
						results_string = [results_string '_' num2str(maskthresh)];
					end
				end
				if filter_frequency ~= defaults.filter_frequency;
					results_string = [results_string '_hpf_' num2str(filter_frequency)];
				end
				if (~implicit_flag) & (maskthresh ~= defaults.maskthresh)
					results_string = [results_string '_thr_' num2str(maskthresh)];
				end
				a = exist(results_string,'dir');
				append_digit = 2;
				results_string_pre = results_string;
				if inStruct.dont_smash
					while a
						results_string = [results_string_pre '_' num2str(append_digit)];
						a = exist(results_string,'dir');
						append_digit = append_digit+1;
					end
				else
					if exist(results_string,'dir')
						if ~inStruct.clobber_bit
							removeDir = questdlg('Old results directory found! Delete?','Dir with same name found','Yes','No','No');
							if strcmpi(removeDir,'Yes')
                                fclose('all');
								unix(sprintf('rm -rf %s',results_string));
							end
                        else 
                            fclose('all');
							unix(sprintf('rm -rf %s',results_string));
						end
					end
				end
            else
                if exist(results_string,'dir')
                    if ~inStruct.clobber_bit
						removeDir = questdlg('Old results directory found! Delete?','Dir with same name found','Yes','No','No');
						if strcmpi(removeDir,'Yes')
							unix(sprintf('rm -rf %s',results_dir));
						end
					else
						unix(sprintf('rm -rf %s',results_dir));
					end
                end
			end
            results_string;
            mkdir(results_string);
            cd(results_string);
            rS1 = pwd;
			% percRetained = freqAnalyze_itemwise_DIS(study, subject{subj}, tasks{subj}{task}, filter_frequency, rS1);
            set(0,'DefaultFigureVisible','Off');
            % Now, write metadata about the results to the directory
            if RT_flag == 1
                rt_text = 'yes';
            else
                rt_text = 'no';
            end
            if implicit_flag
                mask_type_text = 'Implicit masking';
            else
                mask_type_text = 'Explicit masking';
			end
            fid = fopen([results_string '_metadata.txt'],'w');
            fprintf(fid,'Date of Analysis:      %s\n',datestr(now));
            fprintf(fid,'Experimenter:          %s\n',getenv('USER'));
            fprintf(fid,'Study:                 %s\n',study);
            fprintf(fid,'Subject:               %s\n',subject{subj});
            fprintf(fid,'Tasks:                 %s \n',tasks{subj}{1:length(tasks{subj})});
            fprintf(fid,'Bold directories:      %d \n',boldirs{subj}{1:length(boldirs{subj})});
            fprintf(fid,'Preprocessing:         %s\n',src_data_flag);
            fprintf(fid,'TR:                    %d\n',TR);
            fprintf(fid,'RTs included:          %s\n',rt_text);
            fprintf(fid,'Masking type:          %s\n',mask_type_text);
            fprintf(fid,'Filter frequency:      %.4f\n',filter_frequency);
            fprintf(fid,'Masking threshold:     %.4f\n',maskthresh);
            if ~skip_art
                fprintf(fid,'Global Mean:           %.4f\n',inStruct.global_mean);
                fprintf(fid,'Motion File Type:      %.4f\n',inStruct.motion_file_type);
                fprintf(fid,'Global Threshold:      %.4f\n',inStruct.global_threshold);
                fprintf(fid,'Motion Threshold:      %.4f\n',inStruct.motion_threshold);
                fprintf(fid,'use_diff_motion:       %.4f\n',inStruct.use_diff_motion);
                fprintf(fid,'use_diff_global:       %.4f\n',inStruct.use_diff_global);
            else
                fprintf(fid,'Global Mean:           %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Motion File Type:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Global Threshold:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Motion Threshold:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'use_diff_motion:       %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'use_diff_global:       %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
            end

            for run = 1:num_runs
                cd(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural'));
                clear RT
                % try
                    load(parafiles{run},'spm_inputs','con_info','ips','user_regressors','RT','design','item_vector');
                % catch
                %     load(parafiles{run},'spm_inputs','con_info','ips','user_regressors','RT','design');
                % end
                if ~exist('spm_inputs') | ~exist('ips')
                    fprintf('Failed to load behavioural data for subject %s task `%s`\n',subject{subj}, tasks{subj}{task});
                    fprintf('\t-variables "spm_inputs" and "ips" required (and "con_info" is handy)\n');
                    fprintf('\t-crashing on pass %d...\n\n',task);
                    %continue
                elseif ~exist('con_info')
                    fprintf('No ''con_info'' variable detected for subject %s task `%s`\n',subject{subj}, tasks{subj}{task});
%                 elseif ~exist('user_regressors')
%                     fprintf('No ''user_regressors'' variable deteceted for subject %s task `%s`\n',subject{subj}, tasks{subj}{task});
                end

                cd(fullfile(EXPERIMENT_ROOT_DIR,study,subject{subj},'results',results_string));
            
                %---------------------------------------------------
                % User-defined parameters for this analysis
                %---------------------------------------------------
                

                SPM.nscan(run)     = ips;                   % number of scans for each of nsess sessions
                SPM.xY.RT          = TR;                    % experiment TR in seconds
                SPM.xGX.iGXcalc    = {'Scaling'};           % global normalization: OPTIONS:'Scaling'|'None'
                SPM.xX.K.HParam    = filter_frequency;      % high-pass filter cutoff (secs) [Inf = no filtering]
                SPM.xVi.form       = 'none';                % intrinsic autocorrelations: OPTIONS: 'none'|'AR(1) + w'

                % basis functions and timing parameters
                %---------------------------------------------------------------------------
                SPM.xBF.name       = 'hrf';        
                % OPTIONS:'hrf'
                %         'hrf (with time derivative)'
                %         'hrf (with time and dispersion derivatives)'
                %         'Fourier set'
                %         'Fourier set (Hanning)'
                %         'Gamma functions'
                %         'Finite Impulse Response'
                SPM.xBF.T          = 16; %25;            % number of time bins per scan
                SPM.xBF.T0         = 1;  %13;            % reference time bin
                SPM.xBF.UNITS      = 'scans';        % OPTIONS: 'scans'|'secs' for onsets
                SPM.xBF.Volterra   = 1;             % OPTIONS: 1|2 = order of convolution; 1 = no Volterra


                % design (conditions and user specified covariates)
                %---------------------------------------------------------------------------

                %conditions
                %----------

				% check to make sure the onsets are correct
				if max(horzcat(spm_inputs(:).ons)) > ips % saxelab uses vertcat but horzcat should do the same thing
					warning('\n----------------------------------------\nYour maximum onset: %.0f is greater than your ips (%.0f)!\n',max(vertcat(spm_inputs(:).ons)),ips);
					onset_resp = input(sprintf('Do you want to e(x)it, (c)onvert the onsets to TRs, or (p)roceed anyway? (type x or c or p)\t'),'s');
					if strcmpi(onset_resp,'x')
						return;
					elseif strcmpi(onset_resp,'c')
						disp('Fixing onsets for behavioural file %s. Note that this fix is not permanent.',parafiles{run});
						for onsTask = 1:length(spm_inputs)
							spm_inputs(onsTask).ons = spm_inputs(onsTask).ons/2+1;
						end
					end
				end
                for cond = 1:length(spm_inputs)
                    % SUBTRACTING 1 BECAUSE SPM FIRST IMAGE = 0
                    % this is later fixed in jc_get_design before
                    % extracting roi data in roi_batch.
                    % nevertheless, you must code onsets assuming the first
                    % image is 1.
                    SPM.Sess(run).U(cond).ons    = spm_inputs(cond).ons - 1;  % onsets in scans. 
                    SPM.Sess(run).U(cond).name   = {spm_inputs(cond).name};   % name of condition; string from spm_inputs.name
                    SPM.Sess(run).U(cond).dur    = spm_inputs(cond).dur;      % duration in scans from spm_inputs.dur
                    SPM.Sess(run).U(cond).P.name = 'none';                    % 'none' | 'time' | 'other'
                end

                % sample for using parametric modulation
                %SPM.Sess(subj).U(cond).P.name = 'time';      % 'none' | 'time' | 'other'
                %SPM.Sess(subj).U(cond).P.h = 1;              % order of polynomial expansion
                %or
                %SPM.Sess(subj).U(cond).P.name = 'other';     % 'none' | 'time' | 'other'
                %SPM.Sess(subj).U(cond).P.P = param{j}{1}     % vector as long as current U's ons vector
                %SPM.Sess(subj).U(cond).P.h = 1;              % order of polynomial expansion
                
                
                % ---------------------------------------------------
                % to automatically include RT informartion as a regressor
                if RT_flag==1
                    fprintf('\nAdding RT information as a regressor for: %s. . . \n',subject{subj});
%                     try
                        if ~exist('design') && exist('item_vector')
                            d = item_vector; % if design is missing, this will do.
                        else
                            d = design;
                        end

                        % if fixation 0's in RT and design
                        if ~isempty(find(d==0)) && length(RT) == length(d)
                            RT = RT(find(d));
                        end 

                        % generate a vector of all onsets
                        tp=[];tdur=[];
							
                        for i=1:length(spm_inputs)
                            tp   = [tp spm_inputs(i).ons'];
                            tdur = [tdur spm_inputs(i).dur'];
                        end
                        [tp,ord] = sort(tp);% vector of timepoints
                        tdur     = tdur(ord);% sort durations too.

                        % mean-center non-missed RTs
                        RT(find(RT)) = RT(find(RT))-mean(RT(find(RT)));

                        % now make RT regressors
                        RT_run = zeros(1,ips);

                        % RT_run is now a vector of zeros, length=ips, with
                        % each trial onset value set to the mean-centered
                        % RT value. missed trials = 0
                        for i=1:length(tp)
                            RT_run(tp(i):tp(i)+tdur(i)-1) = ones(tdur(i),1)*RT(i);
                        end
                        
                        % convolve RT with an HRF response
                        RT_run = hrf_convolve(RT_run);

                        % add them to user_regressors, to be used in the next step.
                        if exist('user_regressors')
                            user_regressors(end+1).name = 'RT';
                            user_regressors(end+1).ons  = RT_run;
                        else
                            user_regressors(1).name = 'RT';
                            user_regressors(1).ons  = RT_run;
                        end
%                     catch
%                         disp('Error using RTs as regressors')
%                         disp('Common causes: ')
%                         disp('    -No RT or design (or item_vector) saved in behavioral file')
%                         disp('    -RT includes fixation trials, while design does not')
%                         disp('    -# non-fixation onsets in RT, design, and spm_inputs do not match')
%                         disp('    -RT is not formatted as a single vector of length(trials) - no structures, please')
%                     end
                end

                % user-specified covariates
                % -------------------------
                SPM.Sess(run).C.name = {}; num_regressors = 0;
                if exist('user_regressors')
                    for reg=1:length(user_regressors)
                        SPM.Sess(run).C.C(:,reg) = user_regressors(reg).ons;  % [n x c double] covariates (n=regressor, c=vector of images)
                        SPM.Sess(run).C.name = [{SPM.Sess(run).C.name{:}} {user_regressors(reg).name}];   % [1 x c cell] - append to condition names
                    end
                    num_regressors = length(user_regressors);
                else
                    SPM.Sess(run).C.C = [];
                    SPM.Sess(run).C.name = {};
                end

                % make sure defaults are present in workspace
                spm_defaults = spm_defaults_lily;

                % Get filenames for functional scans - changed by "normed"
                %===========================================================================

                % Pull out some information to save for error checking...
                %files{run} =  spm_get('files',sprintf('%s/%s/%s/bold/%.3d',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(run)),filter);
                files{run} = alek_get(sprintf('%s/%s/%s/bold/%.3d',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(run)),filter);
                expected_num_files(run) = ips;
                
                fprintf('loading image files for run %d \n',boldirs{subj}{task}(run));
                %scans = [scans; spm_get('files',sprintf('%s/%s/%s/bold/%.3d',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(run)),filter)];
                scans = [scans; alek_get(sprintf('%s/%s/%s/bold/%.3d',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(run)),filter)];
                clear spm_inputs ips user_regressors
            end % run/acq loop

            % To skip spm_bch_tsampl5
            % =========================================================
            SPM.xX.BCH = 1;
            SPM.xX.dropscan = [];

            % For spm_bch_tsampl5:
            % If you ever have a really, really good reason to omit more than the first
            % scan - and only then - you can use this flag to call up spm_bch_tsampl5,
            % a subroutine which will knock out various rows of your design matrix.
            % Unless it has been radically changed from spm_bch_tsampl3, its spm99
            % predecessor, doing so will almost certainly foul up things like IRF
            % estimation and so forth - so proceed with caution...
            %===========================================================================
            % Usage = Set SPM.dropscan equal to cell array with each cell containing
            % an array of the desired scan indices to drop within each session.  Each
            % cell corresponds to the equivalent session.  The example here is a four-
            % session experiment, dropping the first three scans in each session. Note
            % that the double curly braces are important.  Also make sure to comment out
            % the above two-line section, "To skip spm_bch_tsampl5."

            % SPM.xX.BCH = 1;
            % SPM.dropscan = {{[1:3] [1:3] [1:3] [1:3]}};

            % specify data: matrix of filenames and TR
            %===========================================================================
            SPM.xY.P = scans;

            
            % Run some basic tests before you let spm_fmri_spm_ui do its
            % thing (to test if the loaded information matches bold data)
            for i=1:num_runs
                if isempty(files{i})
                    fprintf('\nNo files matching "%s" were found in the directory\n',filter);
                    fprintf('"%s/%s/%s/bold/%.3d" (run %d)\n\n',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(i),i);
                elseif length(files{i}) < expected_num_files(i)
                    fprintf('\nThe ips doesn''t match the number of image files in\n');
                    fprintf('"%s/%s/%s/bold/%.3d" (run %d)\n\n',EXPERIMENT_ROOT_DIR,study,subject{subj},boldirs{subj}{task}(i),i);
                end
            
            end
            
            save SPM SPM
            pwd_art = pwd;
            
            % SAVE user information in the results directory.
            
            % Configure design matrix
            %===========================================================================
                % try
                    SPM = spm_fmri_spm_ui_pleiades(SPM);
                % catch
                %     disp('Failed to create design')
                %     disp('Common causes: ')
                %     disp('    -The targeted data (swr / sr) doesn''t exist')
                %     disp('    -The ips doesn`t match the actual bold data')
                %     disp('    -The onsets or durations lead to invalid references')
                %     disp('    (or permissions, of course)')
                %     break
                % end
                
                if implicit_flag == 1
                    SPM.xM.T           = ones(length(scans),1);
                    SPM.xM.TH          = ones(length(scans),1) * maskthresh;
                    SPM.xM.I           = 0;
                    SPM.xM.VM          = [];
                    SPM.xM.xs.Masking  = 'analysis threshold';
                else
                    skullStripMaker(study,subject{subj},maskthresh)
                    SPM.xM.T           = SPM.xM.T;
                    SPM.xM.TH          = SPM.xM.TH * -Inf;
                    SPM.xM.I           = 0;
                    SPM.xM.VM          = spm_vol([fullfile(EXPERIMENT_ROOT_DIR,study,subject{subj},'3danat') '/skull_strip_mask.nii']);
                    SPM.xM.xs.Masking  = sprintf('Skull-stripped mask, made with FSL, threshold: %0.01f',maskthresh);
                end
            
            close all;
            
            if ~skip_art
                art_maker(inStruct, pwd_art, subject{subj}, tasks{subj}{task});
            end
            
            % Estimate parameters
            %===========================================================================
                % try
                    SPM = spm_spm_pleiades(SPM);
                % catch
                %     break
                % end

            % T-contrasts - if con_info existed in any sourced data file,
            % use it now
            %---------------------------------------------------------------------------
            for k=1:num_runs
                load(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural',parafiles{k}),'con_info')
                if exist('con_info')
                    for contrast=1:length(con_info)
                        if k==1, con_vals{contrast} = []; end
                        if exist('RT') && RT_flag==1
                            con_vals{contrast} = [con_vals{contrast} con_info(contrast).vals 0];
                        else
                            con_vals{contrast} = [con_vals{contrast} con_info(contrast).vals];
                        end
                        con_name{contrast} = con_info(contrast).name;
                        n=numel(SPM.Sess(k).col)-(numel(con_info(contrast).vals)+(exist('RT') & RT_flag==1));
                        if n>0,
                            disp(['warning: incorrect number of contrast values for contrast #',num2str(contrast),' in run # ',num2str(k),' (',num2str(n),' values missing)']);
                            con_vals{contrast}=[con_vals{contrast},zeros(1,n)];
                        end
                    end
                end
            end
            for contrast=1:length(con_info)
                % if task is only 1 run, uncomment the following line
                % for regressors
                % con_vals{contrast}=[con_vals{contrast}, zeros(1,num_runs + num_regressors)]; %zero pad for effects of interest

                % if task is more than one run, use the following line for regressors
                con_vals{contrast}=[con_vals{contrast}, zeros(1,num_runs)];

                %                     try
                if isempty(SPM.xCon)       
                    SPM.xCon = spm_FcUtil('Set', con_name{contrast}, 'T', 'c', con_vals{contrast}',SPM.xX.xKXs);
                else
                    SPM.xCon(end+1) = spm_FcUtil('Set', con_name{contrast}, 'T', 'c', con_vals{contrast}',SPM.xX.xKXs);
                end
%                     catch
%                         fprintf('\n=====\nError specifying contrasts for subject %s task %s\n=====\n',subject{subj},tasks{subj}{task});
%                         rethrow(lasterror)
%                     end
            end %con_info loop
            % ---------------------------------------------------------------------------
            spm_contrasts_pleiades(SPM);
    end % task loop
end % subject loop
end %function model

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function skullStripMaker(study, subj, maskthresh)
    % path1=getenv('PATH');
    % path1=[path1 ':/usr/public/fsl/5.0.8/fsl/bin'];
    % setenv('PATH',path1);
    % !echo PATH
    set(0,'DefaultFigureVisible','on');
    global mask_over;
    global inStruct;
    directory = ['/home/younglw/lab/' study '/' subj '/3danat/'];
    img = dir([directory 'ws0-0*-*-*-*.img']);
    if strcmp(inStruct.src_data_flag,'unnormed')|isempty(img) 
        img = dir([directory 's0-0*-*-*-*.img']);
        if isempty(img)
            pwd1 = pwd;
            cd(directory);
            img = spm_select(1,'img','Could not find proper anatomical file. Please select the anatomical file.');
            cd(pwd1);
        elseif length(img) > 1
            pwd1 = pwd;
            cd(directory);
            img = spm_select(1,'img','There are too many anatomical files present. Please select the anatomical file.');
            cd(pwd1);
        else
            img = [directory img.name];
        end
    elseif length(img) > 1
        pwd1 = pwd;
        cd(directory);
        img = spm_select(1,'img','There are too many anatomical files present. Please select the anatomical file.');
        cd(pwd1);
    else
        img = [directory img.name];
    end
    fprintf('Structural image file: \n');
    fprintf('%s\n',img);
    % keyboard

    % allimg = dir([directory 'ws0-0*-*-*-*.*']);
    nifti=dir([directory 'ws0-0*-*-*-*.nii']);
 
    try
        disp(['Removing nifti file: ' nifti(1).name]);
        eval(sprintf('!rm -rf %s',[directory nifti(1).name]));
    catch
        disp(['No nifti file to remove.'])
    end

    fprintf('Making mask image...\n');
    if ~exist([directory 'skull_strip_mask.img'],'file') | mask_over
        if exist([directory 'skull_strip_mask.img'],'file')
            fprintf('Old mask found!\n');
            fprintf('Attempting to remove old mask...\n');
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.nii.gz']));
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.nii']));
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.img']));

            % system(sprintf('rm -rf %s',[directory 'skull_strip_mask.nii.gz']));
            % system(sprintf('rm -rf %s',[directory 'skull_strip_mask.nii']));

            fprintf('Old mask removed, making new mask...\n');
        end
        eval(sprintf('!bet %s %s -f %0.01f',img,[directory 'skull_strip_mask'],maskthresh));
        % system(sprintf('bet %s %s -f %0.01f',img,[directory 'skull_strip_mask'],maskthresh));

        fprintf('Mask image made, unzipping...\n');
        eval(sprintf('!gunzip %s.nii.gz -f',[directory 'skull_strip_mask']));
        % system(sprintf('gunzip %s.nii.gz -f',[directory 'skull_strip_mask']));
        fprintf('Constructing binary brain mask...\n');
        V = spm_vol([directory 'skull_strip_mask.nii']);
        Vo = struct('fname',[directory 'skull_strip_mask.img'],'dim',[V(1).dim(1:3)],'dt',[spm_type('float32'), 1],'mat',V(1).mat,'descrip','spm - algebra','mask',1);
        Vo = spm_imcalc(V,Vo,'i1>0');
    end
    fprintf('Binary brain mask has been constructed successfully!\n');
    set(0,'DefaultFigureVisible','off');
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function art_maker(inStruct, resDir, artsubj, arttask)
global_mean=        inStruct.global_mean;               % global mean type (1: Standard 2: User-defined Mask)
motion_file_type=	inStruct.motion_file_type;          % motion file type (0: SPM .txt file 1: FSL .par file 2:Siemens .txt file)
global_threshold=	inStruct.global_threshold;          % threshold for outlier detection based on global signal
motion_threshold=   inStruct.motion_threshold;          % threshold for outlier detection based on motion estimates
use_diff_motion=	inStruct.use_diff_motion;           % 1: uses scan-to-scan motion to determine outliers; 0: uses absolute motion
use_diff_global=	inStruct.use_diff_global;           % 1: uses scan-to-scan global signal change to determine outliers; 0: uses absolute global signal values
use_norms=          1;                                  % 1: uses composite motion measure (largest voxel movement) to determine outliers; 0: uses raw motion measures (translation/rotation parameters) 
mask_file=          [];                                 % set to user-defined mask file(s) for global signal estimation (if global_mean is set to 2) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
STEPS=[1,1];
pwd1 = resDir;

if STEPS(1),
    files = fullfile(pwd1,'SPM.mat');
    for n1 = 1:size(files,1)
        cfgfile=fullfile(pwd,['art_config',num2str(n1,'%03d'),'.cfg']);
        fid=fopen(cfgfile,'wt');
        [filepath,filename,fileext]=fileparts(deblank(files(n1,:)));
        load(deblank(files(n1,:)),'SPM');
        fprintf(fid,'# Automatic script generated by %s\n',mfilename);
        fprintf(fid,'# Users can edit this file and use\n');
        fprintf(fid,'#   art(''sess_file'',''%s'');\n',cfgfile);
        fprintf(fid,'# to launch art using this configuration\n');
        fprintf(fid,'sessions: %d\n',length(SPM.Sess));
        fprintf(fid,'global_mean: %d\n',global_mean);
        fprintf(fid,'global_threshold: %f\n',global_threshold);
        fprintf(fid,'motion_threshold: %f\n',motion_threshold);
        fprintf(fid,'motion_file_type: %d\n',0);
        fprintf(fid,'motion_fname_from_image_fname: 1\n');
        fprintf(fid,'use_diff_motion: %d\n',use_diff_motion);
        fprintf(fid,'use_diff_global: %d\n',use_diff_global);
        fprintf(fid,'use_norms: %d\n',use_norms);
        fprintf(fid,'spm_file: %s\n',deblank(files(n1,:)));
        fprintf(fid,'output_dir: %s\n',fileparts(files(n1,:)));
        
        if ~isempty(mask_file)
            fprintf(fid,'mask_file: %s\n',deblank(mask_file(n1,:)));
        end
        
        fprintf(fid,'end\n');
        
        for n2=1:length(SPM.Sess)
            temp=[SPM.xY.P(SPM.Sess(n2).row,:),repmat(' ',[length(SPM.Sess(n2).row),1])]';
            fprintf(fid,'session %d image %s\n',n2,temp(:)');
        end
        
        fprintf(fid,'end\n');
        fclose(fid);
    end
end

if STEPS(2)
    for n1=1:size(files,1)
        cfgfile=fullfile(pwd,['art_config',num2str(n1,'%03d'),'.cfg']);
        disp(['running subject ',num2str(n1),' using config file ',cfgfile]);
        art('sess_file',cfgfile);
        set(gcf,'name',['art_batch: art subject #',num2str(n1)]);
    end
end
if inStruct.saveim
    eval(['saveas(get(0,''children''),' sprintf('''artifact_analysis_%s_%s.png''',artsubj,arttask) ')']);
end
close(get(0,'children'));
end